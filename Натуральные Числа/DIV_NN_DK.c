//Подгружаемые модули:
//MUL_Nk_N.c
//COM_NN_D.c
//SUB_NN_N.c
//Прототип: struct NATURAL DIV_NN_Dk(struct NATURAL, struct NATURAL); где
//1-ый параметр - структура с массивом цифр A и номером старшего разряда index делимого
//2-ой параметр - структура с массивом цифр A и номером старшего разряда index делителя
//Возвращает значение первой цифры от деления большего натурального на меньшее, домноженной на 10^k,где k - номер позиции этой цифры
//Выполнили Романова А., Аббасова Т. гр.4307
#include "../build/main.h"

struct NATURAL DIV_NN_Dk(struct NATURAL A, struct NATURAL B)
{
	int flag, index, k; //k - степень, в которую потом будем возводить 10; index - старший коэффициент вспомогательной структуры
	struct NATURAL Test, D; //Test - вспомогательная структура; D - структура для хранения первого числа от деления A на В
	Test.index = B.index; //старший разряд вспомогательной структуры
	D.index = 0; // старший разряд первого числа от деления А на В
	Test.number = (int*)malloc((Test.index + 1)*sizeof(int));
	D.number = (int*)malloc(sizeof(int));

	for (int i = A.index - Test.index, i1 = 0; i <= A.index; i++, i1++)
		Test.number[i1] = A.number[i]; //присваивание первых n чисел делимого вспомогательному числу. n - старший разряд вспомогательного числа
	if (COM_NN_D(Test, B))
	{
		if (COM_NN_D(Test, B) == 1) //если вспомогательное число меньше делителя
		{
			Test.index++; //увеличение старшего разряда вспомогательного числа на 1
			Test.number = (int*)realloc(Test.number, (Test.index + 1)*sizeof(int));
			for (int i = Test.index; i > 0; i--)
				Test.number[i] = Test.number[i - 1]; //уменьшение разряда каждого числа на 1
			Test.number[0] = A.number[A.index - Test.index]; //добавление в старший разряд числа делимого, стоящего на n-ой позиции. n - старший разряд вспомогательного числа
		}
		index = Test.index; //сохранение старшего разряда вспомогательного числа
		D.number[0] = 0; //обнуление значения первого числа от деления А на В
		do {
			Test = SUB_NN_N(Test, B); //нахождение разности вспомогательного числа и вычитаемого
			D.number[0]++;//накапливание значения первого числа от делени А на В
			flag = COM_NN_D(Test, B);//проверка, меньше ли разность, чем вычитаемое
		}	while (flag != 1); //пока разность больше либо равна вычитаемому
		k = A.index - index; //нахождение старшего разряда числа, полученного от деления А на В
	}
	else
	{
		if (COM_NN_D(Test, B) == 0)//если вспомогательное число равно делителю
		{
			D.number[0] = 1;//первое число от деления вспомогательного числа на делитель
			k = A.index - Test.index;//старший разряд числа, полученного от деления А на В
		}
	}
	return MUL_Nk_N(D, k); //умножение первого числа от деления А на В на 10^k и возврат этого значения
}
